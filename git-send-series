#!/usr/bin/env ruby

require 'fileutils'
require 'yaml'

BASE_DIR = "~/.config/git/patch-series/"

branches = ARGV

def die(*args)
  fmt = args.shift
  $stderr.printf("fatal: %s\n" % fmt, *args)
  exit 128
end

class Branch

  attr_reader :id, :summary, :body, :prefix
  attr_reader :file

  def initialize(name)
    @name = name
    @id = name.tr('/', '-')
    @file = File.expand_path(File.join(BASE_DIR, @id + '.txt'))
  end

  def parse
    die "Missing #{@name}" unless File.readable?(@file)
    header, @cover = File.read(@file).split("\n\n", 2)
    @data = YAML.load(header) || {}
    @summary, @body = @cover.split("\n\n", 2)

    try = self['try']
    version = self['version']
    prefix = [ self['rfc'] ? 'RFC/PATCH' : 'PATCH' ]
    prefix << "v#{version}" if version
    prefix << "try#{try}" if try
    @prefix = prefix.join(' ')
  end

  def [](name)
    @data[name]
  end

  def []=(name, v)
    @data[name] = v
  end

  def store
    header = @data.to_yaml[4..-1]
    File.write(@file, header + "\n" + @cover)
  end

end

class ParseOpt
  attr_writer :usage

  class Option
    attr_reader :short, :long, :help

    def initialize(short, long, help, &block)
      @block = block
      @short = short
      @long = long
      @help = help
    end

    def call(v)
      @block.call(v)
    end
  end

  def initialize
    @list = {}
  end

  def on(short = nil, long = nil, help = nil, &block)
    opt = Option.new(short, long, help, &block)
    @list[short] = opt if short
    @list[long] = opt if long
  end

  def parse
    if ARGV.member?('-h') or ARGV.member?('--help')
      usage
      exit 0
    end
    seen_dash = false
    ARGV.delete_if do |cur|
      opt = val = nil
      next false if cur[0,1] != '-' or seen_dash
      case cur
      when '--'
        seen_dash = true
        next true
      when /^--no-(.+)$/
        opt = @list[$1]
        val = false
      when /^-([^-])(.+)?$/, /^--(.+?)(?:=(.+))?$/
        opt = @list[$1]
        val = $2 || true
      end
      if opt
        opt.call(val)
        true
      end
    end
  end

  def usage
    def fmt(prefix, str)
      return str ? prefix + str : nil
    end
    puts 'usage: %s' % @usage
    @list.values.uniq.each do |opt|
      s = '    '
      s << ''
      s << [fmt('-', opt.short), fmt('--', opt.long)].compact.join(', ')
      s << ''
      s << '%*s%s' % [26 - s.size, '', opt.help] if opt.help
      puts s
    end
  end

end

opts = ParseOpt.new
opts.usage = 'git send-series [options] <branch>'

opts.on('e', 'edit', 'Edit the branch information') do |v|
  $edit = true
end

opts.parse

branches << `git name-rev --name-only HEAD`.chomp if branches.empty?

branches.each do |name|
  branch = Branch.new(name)

  if $edit
    editor = %x[git var GIT_EDITOR].chomp.split(' ')
    system(*editor, branch.file)
    next
  end

  branch.parse

  extra = []
  extra << "--subject-prefix=#{branch.prefix}"
  extra << "--notes"

  FileUtils.rm_rf(branch.id)
  system('git', 'format-patch', '--quiet', '--cover-letter', '-C', '-o', branch.id, *extra, "^#{name}@{upstream}", name)

  Dir.glob("#{branch.id}/*0000-cover-letter.patch").each do |fn|
    content = File.read(fn)
    content.gsub!('*** SUBJECT HERE ***', branch.summary)
    content.gsub!('*** BLURB HERE ***', branch.body)
    File.write(fn, content)
  end

  extra = []
  extra += ['--no-annotate']

  cc = branch['cc']
  extra += cc.chomp.split(', ').map { |e| ['--cc', e] }.flatten if cc

  patches = Dir.glob("#{branch.id}/*.patch").sort
  mid = nil
  IO.popen(['git', 'send-email'] + extra + patches) do |io|
    io.each do |l|
      case l
      when /^Subject: (.*)$/
        puts "Sent #{$1}"
      when /^Message-Id: <(.*)>$/
        mid ||= $1
      end
    end
  end

  system('git', 'update-ref', '-m', 'sent version',
         'refs/sent/%s/v%s' % [name, branch['version'] || 1], name)

  branch['mid'] = mid
  branch.store
end
