#!/usr/bin/env ruby

require 'fileutils'
require 'yaml'
require 'tempfile'

branches = ARGV

$git_dir = %x[git rev-parse --git-dir].chomp
$base_dir = File.join($git_dir, 'series')
$edit = false
$dry_run = false
$show_cover = false

$template = <<EOF
version:
cc:

Subject

Content.
EOF

def die(*args)
  fmt = args.shift
  $stderr.printf("fatal: %s\n" % fmt, *args)
  exit 128
end

def run_editor(file)
  editor = %x[git var GIT_EDITOR].chomp.split(' ')
  exit 1 unless system(*editor, file)
end

class Branch

  attr_reader :id, :summary, :body
  attr_reader :rfc, :prefix
  attr_reader :file

  def initialize(name)
    @name = name
    @id = name.tr('/', '-')
    @file = File.expand_path(File.join($base_dir, @id))
    @tmp_file = nil
  end

  def edit
    if not File.exist?(@file)
      FileUtils.mkdir_p($base_dir)
      File.write(@file, $template)
    end
    @tmp_file = Tempfile.new('git-send-series')
    @tmp_file.write(File.read(@file))
    @tmp_file.close
    run_editor(@tmp_file.path)
    exit 1 if @tmp_file.size == 0
    File.write(@file, File.read(@tmp_file))
    @tmp_file.unlink
  end

  def parse
    begin
      header, @cover = File.read(@file).split("\n\n", 2)
      @data = YAML.load(header) || {}
      @summary, @body = @cover.split("\n\n", 2)
    rescue
      $stderr.puts 'Parsing error'
      exit 1
    end

    @rfc = self['rfc']
    if self['try']
      prefix = [ @rfc ? 'RFC/PATCH' : 'PATCH' ]
      prefix << "try" + self['try']
      @prefix = prefix.join(' ')
    end
  end

  def [](name)
    @data[name]
  end

  def []=(name, v)
    @data[name] = v
  end

  def version
    @data['version']
  end

  def version=(v)
    @data['version'] = v
  end

  def store
    header = @data.to_yaml[4..-1]
    File.write(@file, header + "\n" + @cover)
  end

end

class ParseOpt
  attr_writer :usage

  class Option
    attr_reader :short, :long, :help

    def initialize(short, long, help, &block)
      @block = block
      @short = short
      @long = long
      @help = help
    end

    def call(v)
      @block.call(v)
    end
  end

  def initialize
    @list = {}
  end

  def on(short = nil, long = nil, help = nil, &block)
    opt = Option.new(short, long, help, &block)
    @list[short] = opt if short
    @list[long] = opt if long
  end

  def parse
    if ARGV.member?('-h') or ARGV.member?('--help')
      usage
      exit 0
    end
    seen_dash = false
    ARGV.delete_if do |cur|
      opt = val = nil
      next false if cur[0,1] != '-' or seen_dash
      case cur
      when '--'
        seen_dash = true
        next true
      when /^--no-(.+)$/
        opt = @list[$1]
        val = false
      when /^-([^-])(.+)?$/, /^--(.+?)(?:=(.+))?$/
        opt = @list[$1]
        val = $2 || true
      end
      if opt
        opt.call(val)
        true
      end
    end
  end

  def usage
    def fmt(prefix, str)
      return str ? prefix + str : nil
    end
    puts 'usage: %s' % @usage
    @list.values.uniq.each do |opt|
      s = '    '
      s << ''
      s << [fmt('-', opt.short), fmt('--', opt.long)].compact.join(', ')
      s << ''
      s << '%*s%s' % [26 - s.size, '', opt.help] if opt.help
      puts s
    end
  end

end

opts = ParseOpt.new
opts.usage = 'git send-series [options] <branch>'

opts.on('e', 'edit', 'Edit the branch information') do |v|
  $edit = true
end

opts.on('d', 'dry-run', 'Do a dry run') do |v|
  $dry_run = true
end

opts.on('s', 'show', 'Show cover-letter before sending') do |v|
  $show_cover = true
end

opts.parse

branches << `git name-rev --name-only HEAD`.chomp if branches.empty?

def get_sent(name, v)
  ref = 'refs/sent/%s/v%d' % [name, v]
  system('git', 'rev-parse', '-q', '--verify', ref, err: File::NULL, out: File::NULL) ? ref : nil
end

branches.each do |name|
  branch = Branch.new(name)

  if $edit
    branch.edit
    next
  end

  branch.edit
  branch.parse
  previous = nil

  if branch.version
    if get_sent(name, branch.version)
      die "Already sent v%d" % branch.version
    end
    previous = get_sent(name, branch.version - 1)
  end

  extra = []
  if branch.prefix
    extra << "--subject-prefix=#{branch.prefix}"
  else
    extra << "--rfc=#{branch.rfc}" if branch.rfc
    extra << "--reroll-count=#{branch.version}" if branch.version
  end
  extra << "--notes"
  extra << "--range-diff=#{previous}" if previous

  FileUtils.rm_rf(branch.id)
  system('git', 'format-patch', '--quiet', '--cover-letter', '-C', '-D', '-o', branch.id, *extra, "^#{name}@{upstream}", name)

  Dir.glob("#{branch.id}/*0000-cover-letter.patch").each do |fn|
    content = File.read(fn)
    content.gsub!('*** SUBJECT HERE ***', branch.summary)
    content.gsub!('*** BLURB HERE ***', branch.body.chomp(''))
    File.write(fn, content)
    run_editor(fn) if $show_cover
  end

  next if $dry_run

  extra = []
  extra += ['--no-annotate']

  to = branch['to']
  extra += to.chomp.split(', ').map { |e| ['--to', e] }.flatten if to

  cc = branch['cc']
  extra += cc.chomp.split(', ').map { |e| ['--cc', e] }.flatten if cc

  patches = Dir.glob("#{branch.id}/*.patch").sort
  mid = nil
  IO.popen(['git', 'send-email'] + extra + patches) do |io|
    io.each do |l|
      case l
      when /^Subject: (.*)$/
        puts "Sent #{$1}"
      when /^Message-Id: <(.*)>$/
        mid ||= $1
      end
    end
  end

  branch.version ||= 1

  system('git', 'update-ref', '-m', 'sent version',
         'refs/sent/%s/v%d' % [name, branch.version], name)

  branch['mid'] = mid
  branch.store

  FileUtils.rm_rf(branch.id)
end
